import tkinter as tk
from tkinter import filedialog, messagebox, ttk
from PIL import Image, ImageTk
import cv2
import numpy as np
import os
import io
from threading import Thread
from rembg import remove
from ultralytics import YOLO

class BackgroundRemoverApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Eliminador Profesional – Con Detección YOLOv8")
        self.root.geometry("1000x760")
        self.root.configure(bg="#f5f5f5")

        # Cargar modelo YOLOv8-seg (segmentación)
        self.model = YOLO('yolov8n-seg.pt')  # Modelo ligero, preciso
        self.input_image_paths = []
        self.processed_images = {}
        self.thumbnail_size = (120, 120)
        self.max_images = 50

        # Título
        title = tk.Label(
            root,
            text="✅ Eliminador con YOLOv8 – Segmentación Precisa para Zapatillas",
            font=("Arial", 16, "bold"),
            bg="#f5f5f5",
            fg="#2c3e50"
        )
        title.pack(pady=10)

        # Botones
        btn_frame = tk.Frame(root, bg="#f5f5f5")
        btn_frame.pack(pady=10)

        self.load_btn = tk.Button(btn_frame, text="Cargar Imágenes", command=self.load_images, width=22, height=2, bg="#2ecc71", fg="white")
        self.load_btn.grid(row=0, column=0, padx=8)

        self.remove_btn = tk.Button(btn_frame, text="Eliminar Fondos (YOLOv8)", command=self.start_removal, width=22, height=2, state=tk.DISABLED, bg="#3498db", fg="white")
        self.remove_btn.grid(row=0, column=1, padx=8)

        self.save_btn = tk.Button(btn_frame, text="Guardar Todas", command=self.save_all, width=22, height=2, state=tk.DISABLED, bg="#e67e22", fg="white")
        self.save_btn.grid(row=0, column=2, padx=8)

        self.info_label = tk.Label(root, text="Imágenes cargadas: 0", bg="#f5f5f5")
        self.info_label.pack()

        # Canvas con scroll
        canvas_frame = tk.Frame(root)
        canvas_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        self.canvas = tk.Canvas(canvas_frame, bg="white", bd=1, relief="sunken")
        scrollbar = ttk.Scrollbar(canvas_frame, orient="vertical", command=self.canvas.yview)
        self.scrollable = tk.Frame(self.canvas, bg="white")

        self.scrollable.bind("<Configure>", lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))
        self.canvas.create_window((0, 0), window=self.scrollable, anchor="nw")
        self.canvas.configure(yscrollcommand=scrollbar.set)

        self.canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # Progreso
        self.progress = ttk.Progressbar(root, length=400, mode="determinate")
        self.progress.pack(pady=8)
        self.progress_label = tk.Label(root, text="", bg="#f5f5f5")
        self.progress_label.pack()

    def load_images(self):
        paths = filedialog.askopenfilenames(
            title="Seleccionar hasta 50 imágenes",
            filetypes=[("Imágenes", "*.png *.jpg *.jpeg *.bmp *.tiff *.webp")]
        )
        if not paths:
            return
        if len(paths) > 50:
            messagebox.showwarning("Límite", "Máximo 50 imágenes.")
            paths = paths[:50]
        self.input_image_paths = list(paths)
        self.processed_images.clear()
        self.update_info()
        self.show_thumbnails()
        self.remove_btn.config(state=tk.NORMAL)
        self.save_btn.config(state=tk.DISABLED)

    def update_info(self):
        self.info_label.config(text=f"Imágenes cargadas: {len(self.input_image_paths)}")

    def show_thumbnails(self):
        for w in self.scrollable.winfo_children():
            w.destroy()
        cols = 6
        for i, p in enumerate(self.input_image_paths):
            r, c = divmod(i, cols)
            try:
                img = Image.open(p).convert("RGB")
                img.thumbnail(self.thumbnail_size, Image.LANCZOS)
                tk_img = ImageTk.PhotoImage(img)
                frm = tk.Frame(self.scrollable, bg="white", padx=4, pady=4)
                frm.grid(row=r, column=c, padx=4, pady=4)
                lbl = tk.Label(frm, image=tk_img, bg="white")
                lbl.image = tk_img
                lbl.pack()
                name = os.path.basename(p)[:18]
                tk.Label(frm, text=name + ("…" if len(os.path.basename(p)) > 18 else ""), bg="white", font=("Arial", 8)).pack()
            except Exception as e:
                print(f"Error miniatura: {e}")

    def is_white_product_on_light_background(self, image_path):
        """
        Heurística para detectar fondo claro + producto blanco.
        """
        try:
            img = cv2.imread(image_path)
            if img is None:
                return False

            hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
            _, _, v = cv2.split(hsv)

            bright_pixels = np.sum(v > 220)
            total_pixels = v.size
            bright_ratio = bright_pixels / total_pixels

            std_r = np.std(img[:, :, 2])
            std_g = np.std(img[:, :, 1])
            std_b = np.std(img[:, :, 0])
            avg_std = (std_r + std_g + std_b) / 3

            if bright_ratio > 0.6 and avg_std < 40:
                return True
            return False
        except Exception as e:
            print(f"Error en detección: {e}")
            return False

    def get_yolo_mask(self, image_path):
        """
        Usa YOLOv8 para generar máscara de segmentación del objeto principal.
        """
        try:
            results = self.model(image_path, conf=0.25, imgsz=640)  # Baja confianza para capturar más objetos
            if len(results[0].masks) == 0:
                return None

            # Tomar la máscara más grande (objeto principal)
            masks = results[0].masks.data.cpu().numpy()
            areas = [np.sum(mask) for mask in masks]
            best_idx = np.argmax(areas)
            mask = masks[best_idx]

            # Convertir a uint8 y redimensionar al tamaño original
            img = cv2.imread(image_path)
            h, w = img.shape[:2]
            mask_resized = cv2.resize(mask.astype(np.uint8) * 255, (w, h), interpolation=cv2.INTER_NEAREST)

            return mask_resized
        except Exception as e:
            print(f"Error en YOLOv8: {e}")
            return None

    def refine_edges_with_yolo(self, original_img, yolo_mask):
        """
        Combina máscara de YOLO con refinamiento de bordes.
        """
        # Convertir a array OpenCV
        img_np = np.array(original_img)  # RGB
        h, w = img_np.shape[:2]

        # Asegurar que la máscara tenga el mismo tamaño
        if yolo_mask.shape != (h, w):
            yolo_mask = cv2.resize(yolo_mask, (w, h), interpolation=cv2.INTER_NEAREST)

        # Suavizar ligeramente la máscara para bordes naturales
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
        yolo_mask = cv2.morphologyEx(yolo_mask, cv2.MORPH_CLOSE, kernel)
        alpha_smooth = cv2.GaussianBlur(yolo_mask.astype(np.float32), (5, 5), 0)
        alpha_final = np.clip(alpha_smooth, 0, 255).astype(np.uint8)

        # Crear imagen RGBA
        result = np.dstack((img_np, alpha_final))
        return Image.fromarray(result, 'RGBA')

    def start_removal(self):
        if not self.input_image_paths:
            messagebox.showwarning("Advertencia", "Carga imágenes primero.")
            return
        self.load_btn.config(state=tk.DISABLED)
        self.remove_btn.config(state=tk.DISABLED)
        thread = Thread(target=self.process_images)
        thread.daemon = True
        thread.start()

    def process_images(self):
        total = len(self.input_image_paths)
        self.progress["maximum"] = total
        for i, path in enumerate(self.input_image_paths):
            try:
                # ✅ Usar YOLOv8 para obtener máscara precisa
                yolo_mask = self.get_yolo_mask(path)
                if yolo_mask is None:
                    # Si YOLO falla, usar rembg como fallback
                    with open(path, "rb") as f:
                        input_data = f.read()
                    output_data = remove(input_data, alpha_matting=True, post_process_mask=True)
                    img_no_bg = Image.open(io.BytesIO(output_data)).convert("RGBA")
                    img_no_bg = self.refine_edges_fallback(img_no_bg)
                else:
                    # ✅ Usar máscara de YOLO → mejor precisión
                    original_img = Image.open(path).convert("RGB")
                    img_no_bg = self.refine_edges_with_yolo(original_img, yolo_mask)

                self.processed_images[path] = img_no_bg
            except Exception as e:
                print(f"Error en {path}: {e}")
                self.processed_images[path] = None

            self.root.after(0, self.update_progress_ui, i + 1, total)

        self.root.after(0, self.on_complete)

    def refine_edges_fallback(self, img_no_bg):
        """Refinamiento si usamos rembg como fallback."""
        img_np = np.array(img_no_bg)
        rgb = img_np[:, :, :3]
        alpha = img_np[:, :, 3]
        binary_mask = (alpha > 10).astype(np.uint8) * 255
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (2, 2))
        dilated = cv2.dilate(binary_mask, kernel, iterations=1)
        alpha_smooth = cv2.GaussianBlur(dilated.astype(np.float32), (3, 3), 0)
        alpha_final = np.clip(alpha_smooth, 0, 255).astype(np.uint8)
        result = np.dstack((rgb, alpha_final))
        return Image.fromarray(result, 'RGBA')

    def update_progress_ui(self, current, total):
        self.progress["value"] = current
        self.progress_label.config(text=f"Procesando: {current}/{total}")

    def on_complete(self):
        self.load_btn.config(state=tk.NORMAL)
        self.remove_btn.config(state=tk.NORMAL)
        self.save_btn.config(state=tk.NORMAL)
        self.progress_label.config(text="✅ ¡Listo! Fondos eliminados con YOLOv8 — sin halos, con transparencia real.")
        messagebox.showinfo("Éxito", f"Se procesaron {len(self.processed_images)} imágenes con precisión máxima.")

    def save_all(self):
        if not self.processed_images:
            messagebox.showwarning("Advertencia", "No hay imágenes procesadas.")
            return
        folder = filedialog.askdirectory(title="Carpeta de destino")
        if not folder:
            return
        saved = 0
        for path, img in self.processed_images.items():
            if img is None:
                continue
            base = os.path.splitext(os.path.basename(path))[0]
            save_path = os.path.join(folder, f"{base}_sin_fondo.png")
            try:
                img.save(save_path, "PNG")
                saved += 1
            except Exception as e:
                print(f"Error al guardar {save_path}: {e}")
        messagebox.showinfo("Guardado", f"Se guardaron {saved} imágenes en:\n{folder}")

if __name__ == "__main__":
    root = tk.Tk()
    app = BackgroundRemoverApp(root)
    root.mainloop()